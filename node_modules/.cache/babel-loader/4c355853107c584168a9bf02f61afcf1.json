{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tab = tab;\n\nvar _dom = require(\"@testing-library/dom\");\n\nvar _utils = require(\"./utils\");\n\nvar _focus = require(\"./focus\");\n\nvar _blur = require(\"./blur\");\n\nfunction getNextElement(currentIndex, shift, elements, focusTrap) {\n  if (focusTrap === document && currentIndex === 0 && shift) {\n    return document.body;\n  } else if (focusTrap === document && currentIndex === elements.length - 1 && !shift) {\n    return document.body;\n  } else {\n    const nextIndex = shift ? currentIndex - 1 : currentIndex + 1;\n    const defaultIndex = shift ? elements.length - 1 : 0;\n    return elements[nextIndex] || elements[defaultIndex];\n  }\n}\n\nfunction tab() {\n  let {\n    shift = false,\n    focusTrap\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _focusTrap$ownerDocum, _focusTrap;\n\n  const previousElement = (0, _utils.getActiveElement)((_focusTrap$ownerDocum = (_focusTrap = focusTrap) == null ? void 0 : _focusTrap.ownerDocument) != null ? _focusTrap$ownerDocum : document);\n\n  if (!focusTrap) {\n    focusTrap = document;\n  }\n\n  const focusableElements = focusTrap.querySelectorAll(_utils.FOCUSABLE_SELECTOR);\n  const enabledElements = [...focusableElements].filter(el => el === previousElement || el.getAttribute('tabindex') !== '-1' && !el.disabled && // Hidden elements are not tabable\n  (0, _utils.isVisible)(el));\n  if (enabledElements.length === 0) return;\n  const orderedElements = enabledElements.map((el, idx) => ({\n    el,\n    idx\n  })).sort((a, b) => {\n    // tabindex has no effect if the active element has tabindex=\"-1\"\n    if (previousElement && previousElement.getAttribute('tabindex') === '-1') {\n      return a.idx - b.idx;\n    }\n\n    const tabIndexA = a.el.getAttribute('tabindex');\n    const tabIndexB = b.el.getAttribute('tabindex');\n    const diff = tabIndexA - tabIndexB;\n    return diff === 0 ? a.idx - b.idx : diff;\n  }).map(_ref => {\n    let {\n      el\n    } = _ref;\n    return el;\n  });\n  const checkedRadio = {};\n  let prunedElements = [];\n  orderedElements.forEach(el => {\n    // For radio groups keep only the active radio\n    // If there is no active radio, keep only the checked radio\n    // If there is no checked radio, treat like everything else\n    if (el.type === 'radio' && el.name) {\n      // If the active element is part of the group, add only that\n      if (previousElement && previousElement.type === el.type && previousElement.name === el.name) {\n        if (el === previousElement) {\n          prunedElements.push(el);\n        }\n\n        return;\n      } // If we stumble upon a checked radio, remove the others\n\n\n      if (el.checked) {\n        prunedElements = prunedElements.filter(e => e.type !== el.type || e.name !== el.name);\n        prunedElements.push(el);\n        checkedRadio[el.name] = el;\n        return;\n      } // If we already found the checked one, skip\n\n\n      if (checkedRadio[el.name]) {\n        return;\n      }\n    }\n\n    prunedElements.push(el);\n  });\n  const index = prunedElements.findIndex(el => el === previousElement);\n  const nextElement = getNextElement(index, shift, prunedElements, focusTrap);\n  const shiftKeyInit = {\n    key: 'Shift',\n    keyCode: 16,\n    shiftKey: true\n  };\n  const tabKeyInit = {\n    key: 'Tab',\n    keyCode: 9,\n    shiftKey: shift\n  };\n  let continueToTab = true; // not sure how to make it so there's no previous element...\n  // istanbul ignore else\n\n  if (previousElement) {\n    // preventDefault on the shift key makes no difference\n    if (shift) _dom.fireEvent.keyDown(previousElement, { ...shiftKeyInit\n    });\n    continueToTab = _dom.fireEvent.keyDown(previousElement, { ...tabKeyInit\n    });\n  }\n\n  const keyUpTarget = !continueToTab && previousElement ? previousElement : nextElement;\n\n  if (continueToTab) {\n    if (nextElement === document.body) {\n      (0, _blur.blur)(previousElement);\n    } else {\n      (0, _focus.focus)(nextElement);\n    }\n  }\n\n  _dom.fireEvent.keyUp(keyUpTarget, { ...tabKeyInit\n  });\n\n  if (shift) {\n    _dom.fireEvent.keyUp(keyUpTarget, { ...shiftKeyInit,\n      shiftKey: false\n    });\n  }\n}\n/*\neslint\n  complexity: \"off\",\n  max-statements: \"off\",\n*/","map":{"version":3,"names":["Object","defineProperty","exports","value","tab","_dom","require","_utils","_focus","_blur","getNextElement","currentIndex","shift","elements","focusTrap","document","body","length","nextIndex","defaultIndex","_focusTrap$ownerDocum","_focusTrap","previousElement","getActiveElement","ownerDocument","focusableElements","querySelectorAll","FOCUSABLE_SELECTOR","enabledElements","filter","el","getAttribute","disabled","isVisible","orderedElements","map","idx","sort","a","b","tabIndexA","tabIndexB","diff","checkedRadio","prunedElements","forEach","type","name","push","checked","e","index","findIndex","nextElement","shiftKeyInit","key","keyCode","shiftKey","tabKeyInit","continueToTab","fireEvent","keyDown","keyUpTarget","blur","focus","keyUp"],"sources":["C:/Users/infol/Desktop/coding/react.js/Food/node_modules/@testing-library/user-event/dist/tab.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tab = tab;\n\nvar _dom = require(\"@testing-library/dom\");\n\nvar _utils = require(\"./utils\");\n\nvar _focus = require(\"./focus\");\n\nvar _blur = require(\"./blur\");\n\nfunction getNextElement(currentIndex, shift, elements, focusTrap) {\n  if (focusTrap === document && currentIndex === 0 && shift) {\n    return document.body;\n  } else if (focusTrap === document && currentIndex === elements.length - 1 && !shift) {\n    return document.body;\n  } else {\n    const nextIndex = shift ? currentIndex - 1 : currentIndex + 1;\n    const defaultIndex = shift ? elements.length - 1 : 0;\n    return elements[nextIndex] || elements[defaultIndex];\n  }\n}\n\nfunction tab({\n  shift = false,\n  focusTrap\n} = {}) {\n  var _focusTrap$ownerDocum, _focusTrap;\n\n  const previousElement = (0, _utils.getActiveElement)((_focusTrap$ownerDocum = (_focusTrap = focusTrap) == null ? void 0 : _focusTrap.ownerDocument) != null ? _focusTrap$ownerDocum : document);\n\n  if (!focusTrap) {\n    focusTrap = document;\n  }\n\n  const focusableElements = focusTrap.querySelectorAll(_utils.FOCUSABLE_SELECTOR);\n  const enabledElements = [...focusableElements].filter(el => el === previousElement || el.getAttribute('tabindex') !== '-1' && !el.disabled && // Hidden elements are not tabable\n  (0, _utils.isVisible)(el));\n  if (enabledElements.length === 0) return;\n  const orderedElements = enabledElements.map((el, idx) => ({\n    el,\n    idx\n  })).sort((a, b) => {\n    // tabindex has no effect if the active element has tabindex=\"-1\"\n    if (previousElement && previousElement.getAttribute('tabindex') === '-1') {\n      return a.idx - b.idx;\n    }\n\n    const tabIndexA = a.el.getAttribute('tabindex');\n    const tabIndexB = b.el.getAttribute('tabindex');\n    const diff = tabIndexA - tabIndexB;\n    return diff === 0 ? a.idx - b.idx : diff;\n  }).map(({\n    el\n  }) => el);\n  const checkedRadio = {};\n  let prunedElements = [];\n  orderedElements.forEach(el => {\n    // For radio groups keep only the active radio\n    // If there is no active radio, keep only the checked radio\n    // If there is no checked radio, treat like everything else\n    if (el.type === 'radio' && el.name) {\n      // If the active element is part of the group, add only that\n      if (previousElement && previousElement.type === el.type && previousElement.name === el.name) {\n        if (el === previousElement) {\n          prunedElements.push(el);\n        }\n\n        return;\n      } // If we stumble upon a checked radio, remove the others\n\n\n      if (el.checked) {\n        prunedElements = prunedElements.filter(e => e.type !== el.type || e.name !== el.name);\n        prunedElements.push(el);\n        checkedRadio[el.name] = el;\n        return;\n      } // If we already found the checked one, skip\n\n\n      if (checkedRadio[el.name]) {\n        return;\n      }\n    }\n\n    prunedElements.push(el);\n  });\n  const index = prunedElements.findIndex(el => el === previousElement);\n  const nextElement = getNextElement(index, shift, prunedElements, focusTrap);\n  const shiftKeyInit = {\n    key: 'Shift',\n    keyCode: 16,\n    shiftKey: true\n  };\n  const tabKeyInit = {\n    key: 'Tab',\n    keyCode: 9,\n    shiftKey: shift\n  };\n  let continueToTab = true; // not sure how to make it so there's no previous element...\n  // istanbul ignore else\n\n  if (previousElement) {\n    // preventDefault on the shift key makes no difference\n    if (shift) _dom.fireEvent.keyDown(previousElement, { ...shiftKeyInit\n    });\n    continueToTab = _dom.fireEvent.keyDown(previousElement, { ...tabKeyInit\n    });\n  }\n\n  const keyUpTarget = !continueToTab && previousElement ? previousElement : nextElement;\n\n  if (continueToTab) {\n    if (nextElement === document.body) {\n      (0, _blur.blur)(previousElement);\n    } else {\n      (0, _focus.focus)(nextElement);\n    }\n  }\n\n  _dom.fireEvent.keyUp(keyUpTarget, { ...tabKeyInit\n  });\n\n  if (shift) {\n    _dom.fireEvent.keyUp(keyUpTarget, { ...shiftKeyInit,\n      shiftKey: false\n    });\n  }\n}\n/*\neslint\n  complexity: \"off\",\n  max-statements: \"off\",\n*/"],"mappings":"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"},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.type = type;\nexports.specialCharMap = void 0;\n\nvar _dom = require(\"@testing-library/dom\");\n\nvar _utils = require(\"./utils\");\n\nvar _click = require(\"./click\");\n\nvar _navigationKey = require(\"./keys/navigation-key\"); // TODO: wrap in asyncWrapper\n\n\nconst modifierCallbackMap = { ...createModifierCallbackEntries({\n    name: 'shift',\n    key: 'Shift',\n    keyCode: 16,\n    modifierProperty: 'shiftKey'\n  }),\n  ...createModifierCallbackEntries({\n    name: 'ctrl',\n    key: 'Control',\n    keyCode: 17,\n    modifierProperty: 'ctrlKey'\n  }),\n  ...createModifierCallbackEntries({\n    name: 'alt',\n    key: 'Alt',\n    keyCode: 18,\n    modifierProperty: 'altKey'\n  }),\n  ...createModifierCallbackEntries({\n    name: 'meta',\n    key: 'Meta',\n    keyCode: 93,\n    modifierProperty: 'metaKey'\n  }),\n  // capslock is inline because of the need to fire both keydown and keyup on use, while preserving the modifier state.\n  '{capslock}': function capslockOn(_ref) {\n    let {\n      currentElement,\n      eventOverrides\n    } = _ref;\n    const newEventOverrides = {\n      modifierCapsLock: true\n    };\n\n    _dom.fireEvent.keyDown(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    _dom.fireEvent.keyUp(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    return {\n      eventOverrides: newEventOverrides\n    };\n  },\n  '{/capslock}': function capslockOff(_ref2) {\n    let {\n      currentElement,\n      eventOverrides\n    } = _ref2;\n    const newEventOverrides = {\n      modifierCapsLock: false\n    };\n\n    _dom.fireEvent.keyDown(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    _dom.fireEvent.keyUp(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    return {\n      eventOverrides: newEventOverrides\n    };\n  }\n};\nconst specialCharMap = {\n  arrowLeft: '{arrowleft}',\n  arrowRight: '{arrowright}',\n  arrowDown: '{arrowdown}',\n  arrowUp: '{arrowup}',\n  enter: '{enter}',\n  escape: '{esc}',\n  delete: '{del}',\n  backspace: '{backspace}',\n  home: '{home}',\n  end: '{end}',\n  selectAll: '{selectall}',\n  space: '{space}',\n  whitespace: ' '\n};\nexports.specialCharMap = specialCharMap;\nconst specialCharCallbackMap = {\n  [specialCharMap.arrowLeft]: (0, _navigationKey.navigationKey)('ArrowLeft'),\n  [specialCharMap.arrowRight]: (0, _navigationKey.navigationKey)('ArrowRight'),\n  [specialCharMap.arrowDown]: handleArrowDown,\n  [specialCharMap.arrowUp]: handleArrowUp,\n  [specialCharMap.home]: (0, _navigationKey.navigationKey)('Home'),\n  [specialCharMap.end]: (0, _navigationKey.navigationKey)('End'),\n  [specialCharMap.enter]: handleEnter,\n  [specialCharMap.escape]: handleEsc,\n  [specialCharMap.delete]: handleDel,\n  [specialCharMap.backspace]: handleBackspace,\n  [specialCharMap.selectAll]: handleSelectall,\n  [specialCharMap.space]: handleSpace,\n  [specialCharMap.whitespace]: handleSpace\n};\n\nfunction wait(time) {\n  return new Promise(resolve => setTimeout(() => resolve(), time));\n} // this needs to be wrapped in the event/asyncWrapper for React's act and angular's change detection\n// depending on whether it will be async.\n\n\nasync function type(element, text) {\n  let {\n    delay = 0,\n    ...options\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // we do not want to wrap in the asyncWrapper if we're not\n  // going to actually be doing anything async, so we only wrap\n  // if the delay is greater than 0\n  let result;\n\n  if (delay > 0) {\n    await (0, _dom.getConfig)().asyncWrapper(async () => {\n      result = await typeImpl(element, text, {\n        delay,\n        ...options\n      });\n    });\n  } else {\n    result = typeImpl(element, text, {\n      delay,\n      ...options\n    });\n  }\n\n  return result;\n}\n\nasync function typeImpl(element, text, _ref3) {\n  let {\n    delay,\n    skipClick = false,\n    skipAutoClose = false,\n    initialSelectionStart,\n    initialSelectionEnd\n  } = _ref3;\n  if (element.disabled) return;\n  if (!skipClick) (0, _click.click)(element);\n\n  if ((0, _utils.isContentEditable)(element) && document.getSelection().rangeCount === 0) {\n    const range = document.createRange();\n    range.setStart(element, 0);\n    range.setEnd(element, 0);\n    document.getSelection().addRange(range);\n  } // The focused element could change between each event, so get the currently active element each time\n\n\n  const currentElement = () => (0, _utils.getActiveElement)(element.ownerDocument); // by default, a new element has it's selection start and end at 0\n  // but most of the time when people call \"type\", they expect it to type\n  // at the end of the current input value. So, if the selection start\n  // and end are both the default of 0, then we'll go ahead and change\n  // them to the length of the current value.\n  // the only time it would make sense to pass the initialSelectionStart or\n  // initialSelectionEnd is if you have an input with a value and want to\n  // explicitely start typing with the cursor at 0. Not super common.\n\n\n  const value = (0, _utils.getValue)(currentElement());\n  const {\n    selectionStart,\n    selectionEnd\n  } = (0, _utils.getSelectionRange)(element);\n\n  if (value != null && selectionStart === 0 && selectionEnd === 0) {\n    (0, _utils.setSelectionRangeIfNecessary)(currentElement(), initialSelectionStart != null ? initialSelectionStart : value.length, initialSelectionEnd != null ? initialSelectionEnd : value.length);\n  }\n\n  const eventCallbacks = queueCallbacks();\n  await runCallbacks(eventCallbacks);\n\n  function queueCallbacks() {\n    const callbacks = [];\n    let remainingString = text;\n\n    while (remainingString) {\n      const {\n        callback,\n        remainingString: newRemainingString\n      } = getNextCallback(remainingString, skipAutoClose);\n      callbacks.push(callback);\n      remainingString = newRemainingString;\n    }\n\n    return callbacks;\n  }\n\n  async function runCallbacks(callbacks) {\n    const eventOverrides = {};\n    let prevWasMinus, prevWasPeriod, prevValue, typedValue;\n\n    for (const callback of callbacks) {\n      if (delay > 0) await wait(delay);\n\n      if (!currentElement().disabled) {\n        const returnValue = callback({\n          currentElement,\n          prevWasMinus,\n          prevWasPeriod,\n          prevValue,\n          eventOverrides,\n          typedValue\n        });\n        Object.assign(eventOverrides, returnValue == null ? void 0 : returnValue.eventOverrides);\n        prevWasMinus = returnValue == null ? void 0 : returnValue.prevWasMinus;\n        prevWasPeriod = returnValue == null ? void 0 : returnValue.prevWasPeriod;\n        prevValue = returnValue == null ? void 0 : returnValue.prevValue;\n        typedValue = returnValue == null ? void 0 : returnValue.typedValue;\n      }\n    }\n  }\n}\n\nfunction getNextCallback(remainingString, skipAutoClose) {\n  const modifierCallback = getModifierCallback(remainingString, skipAutoClose);\n\n  if (modifierCallback) {\n    return modifierCallback;\n  }\n\n  const specialCharCallback = getSpecialCharCallback(remainingString);\n\n  if (specialCharCallback) {\n    return specialCharCallback;\n  }\n\n  return getTypeCallback(remainingString);\n}\n\nfunction getModifierCallback(remainingString, skipAutoClose) {\n  const modifierKey = Object.keys(modifierCallbackMap).find(key => remainingString.startsWith(key));\n\n  if (!modifierKey) {\n    return null;\n  }\n\n  const callback = modifierCallbackMap[modifierKey]; // if this modifier has an associated \"close\" callback and the developer\n  // doesn't close it themselves, then we close it for them automatically\n  // Effectively if they send in: '{alt}a' then we type: '{alt}a{/alt}'\n\n  if (!skipAutoClose && callback.closeName && !remainingString.includes(callback.closeName)) {\n    remainingString += callback.closeName;\n  }\n\n  remainingString = remainingString.slice(modifierKey.length);\n  return {\n    callback,\n    remainingString\n  };\n}\n\nfunction getSpecialCharCallback(remainingString) {\n  const specialChar = Object.keys(specialCharCallbackMap).find(key => remainingString.startsWith(key));\n\n  if (!specialChar) {\n    return null;\n  }\n\n  return {\n    callback: specialCharCallbackMap[specialChar],\n    remainingString: remainingString.slice(specialChar.length)\n  };\n}\n\nfunction getTypeCallback(remainingString) {\n  const character = remainingString[0];\n\n  const callback = context => typeCharacter(character, context);\n\n  return {\n    callback,\n    remainingString: remainingString.slice(1)\n  };\n}\n\nfunction setSelectionRange(_ref4) {\n  let {\n    currentElement,\n    newValue,\n    newSelectionStart\n  } = _ref4;\n  // if we *can* change the selection start, then we will if the new value\n  // is the same as the current value (so it wasn't programatically changed\n  // when the fireEvent.input was triggered).\n  // The reason we have to do this at all is because it actually *is*\n  // programmatically changed by fireEvent.input, so we have to simulate the\n  // browser's default behavior\n  const value = (0, _utils.getValue)(currentElement());\n\n  if (value === newValue) {\n    (0, _utils.setSelectionRangeIfNecessary)(currentElement(), newSelectionStart, newSelectionStart);\n  } else {\n    // If the currentValue is different than the expected newValue and we *can*\n    // change the selection range, than we should set it to the length of the\n    // currentValue to ensure that the browser behavior is mimicked.\n    (0, _utils.setSelectionRangeIfNecessary)(currentElement(), value.length, value.length);\n  }\n}\n\nfunction fireInputEventIfNeeded(_ref5) {\n  let {\n    currentElement,\n    newValue,\n    newSelectionStart,\n    eventOverrides\n  } = _ref5;\n  const prevValue = (0, _utils.getValue)(currentElement());\n\n  if (!currentElement().readOnly && !(0, _utils.isClickableInput)(currentElement()) && newValue !== prevValue) {\n    if ((0, _utils.isContentEditable)(currentElement())) {\n      _dom.fireEvent.input(currentElement(), {\n        target: {\n          textContent: newValue\n        },\n        ...eventOverrides\n      });\n    } else {\n      _dom.fireEvent.input(currentElement(), {\n        target: {\n          value: newValue\n        },\n        ...eventOverrides\n      });\n    }\n\n    setSelectionRange({\n      currentElement,\n      newValue,\n      newSelectionStart\n    });\n  }\n\n  return {\n    prevValue\n  };\n}\n\nfunction typeCharacter(char, _ref6) {\n  let {\n    currentElement,\n    prevWasMinus = false,\n    prevWasPeriod = false,\n    prevValue = '',\n    typedValue = '',\n    eventOverrides\n  } = _ref6;\n  const key = char; // TODO: check if this also valid for characters with diacritic markers e.g. úé etc\n\n  const keyCode = char.charCodeAt(0);\n  let nextPrevWasMinus, nextPrevWasPeriod;\n  const textToBeTyped = typedValue + char;\n\n  const keyDownDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyDownDefaultNotPrevented) {\n    const keyPressDefaultNotPrevented = _dom.fireEvent.keyPress(currentElement(), {\n      key,\n      keyCode,\n      charCode: keyCode,\n      ...eventOverrides\n    });\n\n    if ((0, _utils.getValue)(currentElement()) != null && keyPressDefaultNotPrevented) {\n      let newEntry = char;\n\n      if (prevWasMinus) {\n        newEntry = `-${char}`;\n      } else if (prevWasPeriod) {\n        newEntry = `${prevValue}.${char}`;\n      }\n\n      if ((0, _utils.isValidDateValue)(currentElement(), textToBeTyped)) {\n        newEntry = textToBeTyped;\n      }\n\n      const timeNewEntry = (0, _utils.buildTimeValue)(textToBeTyped);\n\n      if ((0, _utils.isValidInputTimeValue)(currentElement(), timeNewEntry)) {\n        newEntry = timeNewEntry;\n      }\n\n      const inputEvent = fireInputEventIfNeeded({ ...(0, _utils.calculateNewValue)(newEntry, currentElement()),\n        eventOverrides: {\n          data: key,\n          inputType: 'insertText',\n          ...eventOverrides\n        },\n        currentElement\n      });\n      prevValue = inputEvent.prevValue;\n\n      if ((0, _utils.isValidDateValue)(currentElement(), textToBeTyped)) {\n        _dom.fireEvent.change(currentElement(), {\n          target: {\n            value: textToBeTyped\n          }\n        });\n      }\n\n      fireChangeForInputTimeIfValid(currentElement, prevValue, timeNewEntry); // typing \"-\" into a number input will not actually update the value\n      // so for the next character we type, the value should be set to\n      // `-${newEntry}`\n      // we also preserve the prevWasMinus when the value is unchanged due\n      // to typing an invalid character (typing \"-a3\" results in \"-3\")\n      // same applies for the decimal character.\n\n      if (currentElement().type === 'number') {\n        const newValue = (0, _utils.getValue)(currentElement());\n\n        if (newValue === prevValue && newEntry !== '-') {\n          nextPrevWasMinus = prevWasMinus;\n        } else {\n          nextPrevWasMinus = newEntry === '-';\n        }\n\n        if (newValue === prevValue && newEntry !== '.') {\n          nextPrevWasPeriod = prevWasPeriod;\n        } else {\n          nextPrevWasPeriod = newEntry === '.';\n        }\n      }\n    }\n  }\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  return {\n    prevWasMinus: nextPrevWasMinus,\n    prevWasPeriod: nextPrevWasPeriod,\n    prevValue,\n    typedValue: textToBeTyped\n  };\n}\n\nfunction fireChangeForInputTimeIfValid(currentElement, prevValue, timeNewEntry) {\n  if ((0, _utils.isValidInputTimeValue)(currentElement(), timeNewEntry) && prevValue !== timeNewEntry) {\n    _dom.fireEvent.change(currentElement(), {\n      target: {\n        value: timeNewEntry\n      }\n    });\n  }\n} // yes, calculateNewBackspaceValue and calculateNewValue look extremely similar\n// and you may be tempted to create a shared abstraction.\n// If you, brave soul, decide to so endevor, please increment this count\n// when you inevitably fail: 1\n\n\nfunction calculateNewBackspaceValue(element) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = (0, _utils.getSelectionRange)(element);\n  const value = (0, _utils.getValue)(element);\n  let newValue, newSelectionStart;\n\n  if (selectionStart === null) {\n    // at the end of an input type that does not support selection ranges\n    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793\n    newValue = value.slice(0, value.length - 1);\n    newSelectionStart = selectionStart - 1;\n  } else if (selectionStart === selectionEnd) {\n    if (selectionStart === 0) {\n      // at the beginning of the input\n      newValue = value;\n      newSelectionStart = selectionStart;\n    } else if (selectionStart === value.length) {\n      // at the end of the input\n      newValue = value.slice(0, value.length - 1);\n      newSelectionStart = selectionStart - 1;\n    } else {\n      // in the middle of the input\n      newValue = value.slice(0, selectionStart - 1) + value.slice(selectionEnd);\n      newSelectionStart = selectionStart - 1;\n    }\n  } else {\n    // we have something selected\n    const firstPart = value.slice(0, selectionStart);\n    newValue = firstPart + value.slice(selectionEnd);\n    newSelectionStart = firstPart.length;\n  }\n\n  return {\n    newValue,\n    newSelectionStart\n  };\n}\n\nfunction calculateNewDeleteValue(element) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = (0, _utils.getSelectionRange)(element);\n  const value = (0, _utils.getValue)(element);\n  let newValue;\n\n  if (selectionStart === null) {\n    // at the end of an input type that does not support selection ranges\n    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793\n    newValue = value;\n  } else if (selectionStart === selectionEnd) {\n    if (selectionStart === 0) {\n      // at the beginning of the input\n      newValue = value.slice(1);\n    } else if (selectionStart === value.length) {\n      // at the end of the input\n      newValue = value;\n    } else {\n      // in the middle of the input\n      newValue = value.slice(0, selectionStart) + value.slice(selectionEnd + 1);\n    }\n  } else {\n    // we have something selected\n    const firstPart = value.slice(0, selectionStart);\n    newValue = firstPart + value.slice(selectionEnd);\n  }\n\n  return {\n    newValue,\n    newSelectionStart: selectionStart\n  };\n}\n\nfunction createModifierCallbackEntries(_ref7) {\n  let {\n    name,\n    key,\n    keyCode,\n    modifierProperty\n  } = _ref7;\n  const openName = `{${name}}`;\n  const closeName = `{/${name}}`;\n\n  function open(_ref8) {\n    let {\n      currentElement,\n      eventOverrides\n    } = _ref8;\n    const newEventOverrides = {\n      [modifierProperty]: true\n    };\n\n    _dom.fireEvent.keyDown(currentElement(), {\n      key,\n      keyCode,\n      which: keyCode,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    return {\n      eventOverrides: newEventOverrides\n    };\n  }\n\n  open.closeName = closeName;\n\n  function close(_ref9) {\n    let {\n      currentElement,\n      eventOverrides\n    } = _ref9;\n    const newEventOverrides = {\n      [modifierProperty]: false\n    };\n\n    _dom.fireEvent.keyUp(currentElement(), {\n      key,\n      keyCode,\n      which: keyCode,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    return {\n      eventOverrides: newEventOverrides\n    };\n  }\n\n  return {\n    [openName]: open,\n    [closeName]: close\n  };\n}\n\nfunction handleEnter(_ref10) {\n  let {\n    currentElement,\n    eventOverrides\n  } = _ref10;\n  const key = 'Enter';\n  const keyCode = 13;\n\n  const keyDownDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyDownDefaultNotPrevented) {\n    const keyPressDefaultNotPrevented = _dom.fireEvent.keyPress(currentElement(), {\n      key,\n      keyCode,\n      charCode: keyCode,\n      ...eventOverrides\n    });\n\n    if (keyPressDefaultNotPrevented) {\n      if ((0, _utils.isClickableInput)(currentElement()) || // Links with href defined should handle Enter the same as a click\n      (0, _utils.isInstanceOfElement)(currentElement(), 'HTMLAnchorElement') && currentElement().href) {\n        _dom.fireEvent.click(currentElement(), { ...eventOverrides\n        });\n      }\n\n      if (currentElement().tagName === 'TEXTAREA') {\n        const {\n          newValue,\n          newSelectionStart\n        } = (0, _utils.calculateNewValue)('\\n', currentElement());\n\n        _dom.fireEvent.input(currentElement(), {\n          target: {\n            value: newValue\n          },\n          inputType: 'insertLineBreak',\n          ...eventOverrides\n        });\n\n        setSelectionRange({\n          currentElement,\n          newValue,\n          newSelectionStart\n        });\n      }\n\n      if (currentElement().tagName === 'INPUT' && currentElement().form && (currentElement().form.querySelectorAll('input').length === 1 || currentElement().form.querySelector('input[type=\"submit\"]') || currentElement().form.querySelector('button[type=\"submit\"]'))) {\n        _dom.fireEvent.submit(currentElement().form);\n      }\n    }\n  }\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleEsc(_ref11) {\n  let {\n    currentElement,\n    eventOverrides\n  } = _ref11;\n  const key = 'Escape';\n  const keyCode = 27;\n\n  _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  }); // NOTE: Browsers do not fire a keypress on meta key presses\n\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleDel(_ref12) {\n  let {\n    currentElement,\n    eventOverrides\n  } = _ref12;\n  const key = 'Delete';\n  const keyCode = 46;\n\n  const keyPressDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyPressDefaultNotPrevented) {\n    fireInputEventIfNeeded({ ...calculateNewDeleteValue(currentElement()),\n      eventOverrides: {\n        inputType: 'deleteContentForward',\n        ...eventOverrides\n      },\n      currentElement\n    });\n  }\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleBackspace(_ref13) {\n  let {\n    currentElement,\n    eventOverrides\n  } = _ref13;\n  const key = 'Backspace';\n  const keyCode = 8;\n\n  const keyPressDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyPressDefaultNotPrevented) {\n    fireInputEventIfNeeded({ ...calculateNewBackspaceValue(currentElement()),\n      eventOverrides: {\n        inputType: 'deleteContentBackward',\n        ...eventOverrides\n      },\n      currentElement\n    });\n  }\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleSelectall(_ref14) {\n  let {\n    currentElement\n  } = _ref14;\n  currentElement().setSelectionRange(0, (0, _utils.getValue)(currentElement()).length);\n}\n\nfunction handleSpace(context) {\n  if ((0, _utils.isClickableInput)(context.currentElement())) {\n    handleSpaceOnClickable(context);\n    return;\n  }\n\n  typeCharacter(' ', context);\n}\n\nfunction handleSpaceOnClickable(_ref15) {\n  let {\n    currentElement,\n    eventOverrides\n  } = _ref15;\n  const key = ' ';\n  const keyCode = 32;\n\n  const keyDownDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyDownDefaultNotPrevented) {\n    _dom.fireEvent.keyPress(currentElement(), {\n      key,\n      keyCode,\n      charCode: keyCode,\n      ...eventOverrides\n    });\n  }\n\n  const keyUpDefaultNotPrevented = _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyDownDefaultNotPrevented && keyUpDefaultNotPrevented) {\n    _dom.fireEvent.click(currentElement(), { ...eventOverrides\n    });\n  }\n}\n\nfunction handleArrowDown(_ref16) {\n  let {\n    currentElement,\n    eventOverrides\n  } = _ref16;\n  const key = 'ArrowDown';\n  const keyCode = 40;\n\n  _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleArrowUp(_ref17) {\n  let {\n    currentElement,\n    eventOverrides\n  } = _ref17;\n  const key = 'ArrowUp';\n  const keyCode = 38;\n\n  _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","type","specialCharMap","_dom","require","_utils","_click","_navigationKey","modifierCallbackMap","createModifierCallbackEntries","name","key","keyCode","modifierProperty","capslockOn","currentElement","eventOverrides","newEventOverrides","modifierCapsLock","fireEvent","keyDown","which","keyUp","capslockOff","arrowLeft","arrowRight","arrowDown","arrowUp","enter","escape","delete","backspace","home","end","selectAll","space","whitespace","specialCharCallbackMap","navigationKey","handleArrowDown","handleArrowUp","handleEnter","handleEsc","handleDel","handleBackspace","handleSelectall","handleSpace","wait","time","Promise","resolve","setTimeout","element","text","delay","options","result","getConfig","asyncWrapper","typeImpl","skipClick","skipAutoClose","initialSelectionStart","initialSelectionEnd","disabled","click","isContentEditable","document","getSelection","rangeCount","range","createRange","setStart","setEnd","addRange","getActiveElement","ownerDocument","getValue","selectionStart","selectionEnd","getSelectionRange","setSelectionRangeIfNecessary","length","eventCallbacks","queueCallbacks","runCallbacks","callbacks","remainingString","callback","newRemainingString","getNextCallback","push","prevWasMinus","prevWasPeriod","prevValue","typedValue","returnValue","assign","modifierCallback","getModifierCallback","specialCharCallback","getSpecialCharCallback","getTypeCallback","modifierKey","keys","find","startsWith","closeName","includes","slice","specialChar","character","context","typeCharacter","setSelectionRange","newValue","newSelectionStart","fireInputEventIfNeeded","readOnly","isClickableInput","input","target","textContent","char","charCodeAt","nextPrevWasMinus","nextPrevWasPeriod","textToBeTyped","keyDownDefaultNotPrevented","keyPressDefaultNotPrevented","keyPress","charCode","newEntry","isValidDateValue","timeNewEntry","buildTimeValue","isValidInputTimeValue","inputEvent","calculateNewValue","data","inputType","change","fireChangeForInputTimeIfValid","calculateNewBackspaceValue","firstPart","calculateNewDeleteValue","openName","open","close","isInstanceOfElement","href","tagName","form","querySelectorAll","querySelector","submit","handleSpaceOnClickable","keyUpDefaultNotPrevented"],"sources":["C:/Users/infol/Desktop/coding/react.js/Food/node_modules/@testing-library/user-event/dist/type.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.type = type;\nexports.specialCharMap = void 0;\n\nvar _dom = require(\"@testing-library/dom\");\n\nvar _utils = require(\"./utils\");\n\nvar _click = require(\"./click\");\n\nvar _navigationKey = require(\"./keys/navigation-key\");\n\n// TODO: wrap in asyncWrapper\nconst modifierCallbackMap = { ...createModifierCallbackEntries({\n    name: 'shift',\n    key: 'Shift',\n    keyCode: 16,\n    modifierProperty: 'shiftKey'\n  }),\n  ...createModifierCallbackEntries({\n    name: 'ctrl',\n    key: 'Control',\n    keyCode: 17,\n    modifierProperty: 'ctrlKey'\n  }),\n  ...createModifierCallbackEntries({\n    name: 'alt',\n    key: 'Alt',\n    keyCode: 18,\n    modifierProperty: 'altKey'\n  }),\n  ...createModifierCallbackEntries({\n    name: 'meta',\n    key: 'Meta',\n    keyCode: 93,\n    modifierProperty: 'metaKey'\n  }),\n  // capslock is inline because of the need to fire both keydown and keyup on use, while preserving the modifier state.\n  '{capslock}': function capslockOn({\n    currentElement,\n    eventOverrides\n  }) {\n    const newEventOverrides = {\n      modifierCapsLock: true\n    };\n\n    _dom.fireEvent.keyDown(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    _dom.fireEvent.keyUp(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    return {\n      eventOverrides: newEventOverrides\n    };\n  },\n  '{/capslock}': function capslockOff({\n    currentElement,\n    eventOverrides\n  }) {\n    const newEventOverrides = {\n      modifierCapsLock: false\n    };\n\n    _dom.fireEvent.keyDown(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    _dom.fireEvent.keyUp(currentElement(), {\n      key: 'CapsLock',\n      keyCode: 20,\n      which: 20,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    return {\n      eventOverrides: newEventOverrides\n    };\n  }\n};\nconst specialCharMap = {\n  arrowLeft: '{arrowleft}',\n  arrowRight: '{arrowright}',\n  arrowDown: '{arrowdown}',\n  arrowUp: '{arrowup}',\n  enter: '{enter}',\n  escape: '{esc}',\n  delete: '{del}',\n  backspace: '{backspace}',\n  home: '{home}',\n  end: '{end}',\n  selectAll: '{selectall}',\n  space: '{space}',\n  whitespace: ' '\n};\nexports.specialCharMap = specialCharMap;\nconst specialCharCallbackMap = {\n  [specialCharMap.arrowLeft]: (0, _navigationKey.navigationKey)('ArrowLeft'),\n  [specialCharMap.arrowRight]: (0, _navigationKey.navigationKey)('ArrowRight'),\n  [specialCharMap.arrowDown]: handleArrowDown,\n  [specialCharMap.arrowUp]: handleArrowUp,\n  [specialCharMap.home]: (0, _navigationKey.navigationKey)('Home'),\n  [specialCharMap.end]: (0, _navigationKey.navigationKey)('End'),\n  [specialCharMap.enter]: handleEnter,\n  [specialCharMap.escape]: handleEsc,\n  [specialCharMap.delete]: handleDel,\n  [specialCharMap.backspace]: handleBackspace,\n  [specialCharMap.selectAll]: handleSelectall,\n  [specialCharMap.space]: handleSpace,\n  [specialCharMap.whitespace]: handleSpace\n};\n\nfunction wait(time) {\n  return new Promise(resolve => setTimeout(() => resolve(), time));\n} // this needs to be wrapped in the event/asyncWrapper for React's act and angular's change detection\n// depending on whether it will be async.\n\n\nasync function type(element, text, {\n  delay = 0,\n  ...options\n} = {}) {\n  // we do not want to wrap in the asyncWrapper if we're not\n  // going to actually be doing anything async, so we only wrap\n  // if the delay is greater than 0\n  let result;\n\n  if (delay > 0) {\n    await (0, _dom.getConfig)().asyncWrapper(async () => {\n      result = await typeImpl(element, text, {\n        delay,\n        ...options\n      });\n    });\n  } else {\n    result = typeImpl(element, text, {\n      delay,\n      ...options\n    });\n  }\n\n  return result;\n}\n\nasync function typeImpl(element, text, {\n  delay,\n  skipClick = false,\n  skipAutoClose = false,\n  initialSelectionStart,\n  initialSelectionEnd\n}) {\n  if (element.disabled) return;\n  if (!skipClick) (0, _click.click)(element);\n\n  if ((0, _utils.isContentEditable)(element) && document.getSelection().rangeCount === 0) {\n    const range = document.createRange();\n    range.setStart(element, 0);\n    range.setEnd(element, 0);\n    document.getSelection().addRange(range);\n  } // The focused element could change between each event, so get the currently active element each time\n\n\n  const currentElement = () => (0, _utils.getActiveElement)(element.ownerDocument); // by default, a new element has it's selection start and end at 0\n  // but most of the time when people call \"type\", they expect it to type\n  // at the end of the current input value. So, if the selection start\n  // and end are both the default of 0, then we'll go ahead and change\n  // them to the length of the current value.\n  // the only time it would make sense to pass the initialSelectionStart or\n  // initialSelectionEnd is if you have an input with a value and want to\n  // explicitely start typing with the cursor at 0. Not super common.\n\n\n  const value = (0, _utils.getValue)(currentElement());\n  const {\n    selectionStart,\n    selectionEnd\n  } = (0, _utils.getSelectionRange)(element);\n\n  if (value != null && selectionStart === 0 && selectionEnd === 0) {\n    (0, _utils.setSelectionRangeIfNecessary)(currentElement(), initialSelectionStart != null ? initialSelectionStart : value.length, initialSelectionEnd != null ? initialSelectionEnd : value.length);\n  }\n\n  const eventCallbacks = queueCallbacks();\n  await runCallbacks(eventCallbacks);\n\n  function queueCallbacks() {\n    const callbacks = [];\n    let remainingString = text;\n\n    while (remainingString) {\n      const {\n        callback,\n        remainingString: newRemainingString\n      } = getNextCallback(remainingString, skipAutoClose);\n      callbacks.push(callback);\n      remainingString = newRemainingString;\n    }\n\n    return callbacks;\n  }\n\n  async function runCallbacks(callbacks) {\n    const eventOverrides = {};\n    let prevWasMinus, prevWasPeriod, prevValue, typedValue;\n\n    for (const callback of callbacks) {\n      if (delay > 0) await wait(delay);\n\n      if (!currentElement().disabled) {\n        const returnValue = callback({\n          currentElement,\n          prevWasMinus,\n          prevWasPeriod,\n          prevValue,\n          eventOverrides,\n          typedValue\n        });\n        Object.assign(eventOverrides, returnValue == null ? void 0 : returnValue.eventOverrides);\n        prevWasMinus = returnValue == null ? void 0 : returnValue.prevWasMinus;\n        prevWasPeriod = returnValue == null ? void 0 : returnValue.prevWasPeriod;\n        prevValue = returnValue == null ? void 0 : returnValue.prevValue;\n        typedValue = returnValue == null ? void 0 : returnValue.typedValue;\n      }\n    }\n  }\n}\n\nfunction getNextCallback(remainingString, skipAutoClose) {\n  const modifierCallback = getModifierCallback(remainingString, skipAutoClose);\n\n  if (modifierCallback) {\n    return modifierCallback;\n  }\n\n  const specialCharCallback = getSpecialCharCallback(remainingString);\n\n  if (specialCharCallback) {\n    return specialCharCallback;\n  }\n\n  return getTypeCallback(remainingString);\n}\n\nfunction getModifierCallback(remainingString, skipAutoClose) {\n  const modifierKey = Object.keys(modifierCallbackMap).find(key => remainingString.startsWith(key));\n\n  if (!modifierKey) {\n    return null;\n  }\n\n  const callback = modifierCallbackMap[modifierKey]; // if this modifier has an associated \"close\" callback and the developer\n  // doesn't close it themselves, then we close it for them automatically\n  // Effectively if they send in: '{alt}a' then we type: '{alt}a{/alt}'\n\n  if (!skipAutoClose && callback.closeName && !remainingString.includes(callback.closeName)) {\n    remainingString += callback.closeName;\n  }\n\n  remainingString = remainingString.slice(modifierKey.length);\n  return {\n    callback,\n    remainingString\n  };\n}\n\nfunction getSpecialCharCallback(remainingString) {\n  const specialChar = Object.keys(specialCharCallbackMap).find(key => remainingString.startsWith(key));\n\n  if (!specialChar) {\n    return null;\n  }\n\n  return {\n    callback: specialCharCallbackMap[specialChar],\n    remainingString: remainingString.slice(specialChar.length)\n  };\n}\n\nfunction getTypeCallback(remainingString) {\n  const character = remainingString[0];\n\n  const callback = context => typeCharacter(character, context);\n\n  return {\n    callback,\n    remainingString: remainingString.slice(1)\n  };\n}\n\nfunction setSelectionRange({\n  currentElement,\n  newValue,\n  newSelectionStart\n}) {\n  // if we *can* change the selection start, then we will if the new value\n  // is the same as the current value (so it wasn't programatically changed\n  // when the fireEvent.input was triggered).\n  // The reason we have to do this at all is because it actually *is*\n  // programmatically changed by fireEvent.input, so we have to simulate the\n  // browser's default behavior\n  const value = (0, _utils.getValue)(currentElement());\n\n  if (value === newValue) {\n    (0, _utils.setSelectionRangeIfNecessary)(currentElement(), newSelectionStart, newSelectionStart);\n  } else {\n    // If the currentValue is different than the expected newValue and we *can*\n    // change the selection range, than we should set it to the length of the\n    // currentValue to ensure that the browser behavior is mimicked.\n    (0, _utils.setSelectionRangeIfNecessary)(currentElement(), value.length, value.length);\n  }\n}\n\nfunction fireInputEventIfNeeded({\n  currentElement,\n  newValue,\n  newSelectionStart,\n  eventOverrides\n}) {\n  const prevValue = (0, _utils.getValue)(currentElement());\n\n  if (!currentElement().readOnly && !(0, _utils.isClickableInput)(currentElement()) && newValue !== prevValue) {\n    if ((0, _utils.isContentEditable)(currentElement())) {\n      _dom.fireEvent.input(currentElement(), {\n        target: {\n          textContent: newValue\n        },\n        ...eventOverrides\n      });\n    } else {\n      _dom.fireEvent.input(currentElement(), {\n        target: {\n          value: newValue\n        },\n        ...eventOverrides\n      });\n    }\n\n    setSelectionRange({\n      currentElement,\n      newValue,\n      newSelectionStart\n    });\n  }\n\n  return {\n    prevValue\n  };\n}\n\nfunction typeCharacter(char, {\n  currentElement,\n  prevWasMinus = false,\n  prevWasPeriod = false,\n  prevValue = '',\n  typedValue = '',\n  eventOverrides\n}) {\n  const key = char; // TODO: check if this also valid for characters with diacritic markers e.g. úé etc\n\n  const keyCode = char.charCodeAt(0);\n  let nextPrevWasMinus, nextPrevWasPeriod;\n  const textToBeTyped = typedValue + char;\n\n  const keyDownDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyDownDefaultNotPrevented) {\n    const keyPressDefaultNotPrevented = _dom.fireEvent.keyPress(currentElement(), {\n      key,\n      keyCode,\n      charCode: keyCode,\n      ...eventOverrides\n    });\n\n    if ((0, _utils.getValue)(currentElement()) != null && keyPressDefaultNotPrevented) {\n      let newEntry = char;\n\n      if (prevWasMinus) {\n        newEntry = `-${char}`;\n      } else if (prevWasPeriod) {\n        newEntry = `${prevValue}.${char}`;\n      }\n\n      if ((0, _utils.isValidDateValue)(currentElement(), textToBeTyped)) {\n        newEntry = textToBeTyped;\n      }\n\n      const timeNewEntry = (0, _utils.buildTimeValue)(textToBeTyped);\n\n      if ((0, _utils.isValidInputTimeValue)(currentElement(), timeNewEntry)) {\n        newEntry = timeNewEntry;\n      }\n\n      const inputEvent = fireInputEventIfNeeded({ ...(0, _utils.calculateNewValue)(newEntry, currentElement()),\n        eventOverrides: {\n          data: key,\n          inputType: 'insertText',\n          ...eventOverrides\n        },\n        currentElement\n      });\n      prevValue = inputEvent.prevValue;\n\n      if ((0, _utils.isValidDateValue)(currentElement(), textToBeTyped)) {\n        _dom.fireEvent.change(currentElement(), {\n          target: {\n            value: textToBeTyped\n          }\n        });\n      }\n\n      fireChangeForInputTimeIfValid(currentElement, prevValue, timeNewEntry); // typing \"-\" into a number input will not actually update the value\n      // so for the next character we type, the value should be set to\n      // `-${newEntry}`\n      // we also preserve the prevWasMinus when the value is unchanged due\n      // to typing an invalid character (typing \"-a3\" results in \"-3\")\n      // same applies for the decimal character.\n\n      if (currentElement().type === 'number') {\n        const newValue = (0, _utils.getValue)(currentElement());\n\n        if (newValue === prevValue && newEntry !== '-') {\n          nextPrevWasMinus = prevWasMinus;\n        } else {\n          nextPrevWasMinus = newEntry === '-';\n        }\n\n        if (newValue === prevValue && newEntry !== '.') {\n          nextPrevWasPeriod = prevWasPeriod;\n        } else {\n          nextPrevWasPeriod = newEntry === '.';\n        }\n      }\n    }\n  }\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  return {\n    prevWasMinus: nextPrevWasMinus,\n    prevWasPeriod: nextPrevWasPeriod,\n    prevValue,\n    typedValue: textToBeTyped\n  };\n}\n\nfunction fireChangeForInputTimeIfValid(currentElement, prevValue, timeNewEntry) {\n  if ((0, _utils.isValidInputTimeValue)(currentElement(), timeNewEntry) && prevValue !== timeNewEntry) {\n    _dom.fireEvent.change(currentElement(), {\n      target: {\n        value: timeNewEntry\n      }\n    });\n  }\n} // yes, calculateNewBackspaceValue and calculateNewValue look extremely similar\n// and you may be tempted to create a shared abstraction.\n// If you, brave soul, decide to so endevor, please increment this count\n// when you inevitably fail: 1\n\n\nfunction calculateNewBackspaceValue(element) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = (0, _utils.getSelectionRange)(element);\n  const value = (0, _utils.getValue)(element);\n  let newValue, newSelectionStart;\n\n  if (selectionStart === null) {\n    // at the end of an input type that does not support selection ranges\n    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793\n    newValue = value.slice(0, value.length - 1);\n    newSelectionStart = selectionStart - 1;\n  } else if (selectionStart === selectionEnd) {\n    if (selectionStart === 0) {\n      // at the beginning of the input\n      newValue = value;\n      newSelectionStart = selectionStart;\n    } else if (selectionStart === value.length) {\n      // at the end of the input\n      newValue = value.slice(0, value.length - 1);\n      newSelectionStart = selectionStart - 1;\n    } else {\n      // in the middle of the input\n      newValue = value.slice(0, selectionStart - 1) + value.slice(selectionEnd);\n      newSelectionStart = selectionStart - 1;\n    }\n  } else {\n    // we have something selected\n    const firstPart = value.slice(0, selectionStart);\n    newValue = firstPart + value.slice(selectionEnd);\n    newSelectionStart = firstPart.length;\n  }\n\n  return {\n    newValue,\n    newSelectionStart\n  };\n}\n\nfunction calculateNewDeleteValue(element) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = (0, _utils.getSelectionRange)(element);\n  const value = (0, _utils.getValue)(element);\n  let newValue;\n\n  if (selectionStart === null) {\n    // at the end of an input type that does not support selection ranges\n    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793\n    newValue = value;\n  } else if (selectionStart === selectionEnd) {\n    if (selectionStart === 0) {\n      // at the beginning of the input\n      newValue = value.slice(1);\n    } else if (selectionStart === value.length) {\n      // at the end of the input\n      newValue = value;\n    } else {\n      // in the middle of the input\n      newValue = value.slice(0, selectionStart) + value.slice(selectionEnd + 1);\n    }\n  } else {\n    // we have something selected\n    const firstPart = value.slice(0, selectionStart);\n    newValue = firstPart + value.slice(selectionEnd);\n  }\n\n  return {\n    newValue,\n    newSelectionStart: selectionStart\n  };\n}\n\nfunction createModifierCallbackEntries({\n  name,\n  key,\n  keyCode,\n  modifierProperty\n}) {\n  const openName = `{${name}}`;\n  const closeName = `{/${name}}`;\n\n  function open({\n    currentElement,\n    eventOverrides\n  }) {\n    const newEventOverrides = {\n      [modifierProperty]: true\n    };\n\n    _dom.fireEvent.keyDown(currentElement(), {\n      key,\n      keyCode,\n      which: keyCode,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    return {\n      eventOverrides: newEventOverrides\n    };\n  }\n\n  open.closeName = closeName;\n\n  function close({\n    currentElement,\n    eventOverrides\n  }) {\n    const newEventOverrides = {\n      [modifierProperty]: false\n    };\n\n    _dom.fireEvent.keyUp(currentElement(), {\n      key,\n      keyCode,\n      which: keyCode,\n      ...eventOverrides,\n      ...newEventOverrides\n    });\n\n    return {\n      eventOverrides: newEventOverrides\n    };\n  }\n\n  return {\n    [openName]: open,\n    [closeName]: close\n  };\n}\n\nfunction handleEnter({\n  currentElement,\n  eventOverrides\n}) {\n  const key = 'Enter';\n  const keyCode = 13;\n\n  const keyDownDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyDownDefaultNotPrevented) {\n    const keyPressDefaultNotPrevented = _dom.fireEvent.keyPress(currentElement(), {\n      key,\n      keyCode,\n      charCode: keyCode,\n      ...eventOverrides\n    });\n\n    if (keyPressDefaultNotPrevented) {\n      if ((0, _utils.isClickableInput)(currentElement()) || // Links with href defined should handle Enter the same as a click\n      (0, _utils.isInstanceOfElement)(currentElement(), 'HTMLAnchorElement') && currentElement().href) {\n        _dom.fireEvent.click(currentElement(), { ...eventOverrides\n        });\n      }\n\n      if (currentElement().tagName === 'TEXTAREA') {\n        const {\n          newValue,\n          newSelectionStart\n        } = (0, _utils.calculateNewValue)('\\n', currentElement());\n\n        _dom.fireEvent.input(currentElement(), {\n          target: {\n            value: newValue\n          },\n          inputType: 'insertLineBreak',\n          ...eventOverrides\n        });\n\n        setSelectionRange({\n          currentElement,\n          newValue,\n          newSelectionStart\n        });\n      }\n\n      if (currentElement().tagName === 'INPUT' && currentElement().form && (currentElement().form.querySelectorAll('input').length === 1 || currentElement().form.querySelector('input[type=\"submit\"]') || currentElement().form.querySelector('button[type=\"submit\"]'))) {\n        _dom.fireEvent.submit(currentElement().form);\n      }\n    }\n  }\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleEsc({\n  currentElement,\n  eventOverrides\n}) {\n  const key = 'Escape';\n  const keyCode = 27;\n\n  _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  }); // NOTE: Browsers do not fire a keypress on meta key presses\n\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleDel({\n  currentElement,\n  eventOverrides\n}) {\n  const key = 'Delete';\n  const keyCode = 46;\n\n  const keyPressDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyPressDefaultNotPrevented) {\n    fireInputEventIfNeeded({ ...calculateNewDeleteValue(currentElement()),\n      eventOverrides: {\n        inputType: 'deleteContentForward',\n        ...eventOverrides\n      },\n      currentElement\n    });\n  }\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleBackspace({\n  currentElement,\n  eventOverrides\n}) {\n  const key = 'Backspace';\n  const keyCode = 8;\n\n  const keyPressDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyPressDefaultNotPrevented) {\n    fireInputEventIfNeeded({ ...calculateNewBackspaceValue(currentElement()),\n      eventOverrides: {\n        inputType: 'deleteContentBackward',\n        ...eventOverrides\n      },\n      currentElement\n    });\n  }\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleSelectall({\n  currentElement\n}) {\n  currentElement().setSelectionRange(0, (0, _utils.getValue)(currentElement()).length);\n}\n\nfunction handleSpace(context) {\n  if ((0, _utils.isClickableInput)(context.currentElement())) {\n    handleSpaceOnClickable(context);\n    return;\n  }\n\n  typeCharacter(' ', context);\n}\n\nfunction handleSpaceOnClickable({\n  currentElement,\n  eventOverrides\n}) {\n  const key = ' ';\n  const keyCode = 32;\n\n  const keyDownDefaultNotPrevented = _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyDownDefaultNotPrevented) {\n    _dom.fireEvent.keyPress(currentElement(), {\n      key,\n      keyCode,\n      charCode: keyCode,\n      ...eventOverrides\n    });\n  }\n\n  const keyUpDefaultNotPrevented = _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  if (keyDownDefaultNotPrevented && keyUpDefaultNotPrevented) {\n    _dom.fireEvent.click(currentElement(), { ...eventOverrides\n    });\n  }\n}\n\nfunction handleArrowDown({\n  currentElement,\n  eventOverrides\n}) {\n  const key = 'ArrowDown';\n  const keyCode = 40;\n\n  _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}\n\nfunction handleArrowUp({\n  currentElement,\n  eventOverrides\n}) {\n  const key = 'ArrowUp';\n  const keyCode = 38;\n\n  _dom.fireEvent.keyDown(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n\n  _dom.fireEvent.keyUp(currentElement(), {\n    key,\n    keyCode,\n    which: keyCode,\n    ...eventOverrides\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}